<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FAT32 Image Defragmenter: dev/#gpl/defrag/src/defrag.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FAT32 Image Defragmenter&#160;<span id="projectnumber">0.1b</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('defrag_8c.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">dev/#gpl/defrag/src/defrag.c File Reference</div>  </div>
</div>
<div class="contents">

<p>Module performs disk defragmentation.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="defrag_8c.html#a4e460b62f6ad1da6647da2f63650cd73">def_findParent</a> (unsigned long cluster)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="defrag_8c.html#a511415bec7ad1964050f75132234b02b">def_isStarting</a> (unsigned long cluster, unsigned long *index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="defrag_8c.html#a3d279408ee3fb40b39fdb90301698b76">def_findFirstUsable</a> (unsigned long beginCluster, unsigned long *outCluster, unsigned long *outValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="defrag_8c.html#a5e92af3739a90669fb870d93b8b97c82">def_switchClusters</a> (unsigned long cluster1, unsigned long cluster2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="defrag_8c.html#a33103d3c3ed0b1548fc796d18227f6fc">def_optimizeStartCluster</a> (unsigned long startCluster, unsigned long beginCluster, unsigned long *outputCluster)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="defrag_8c.html#a8474fb4182605c5bb62390fd6db533f6">print_bar</a> (int size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="defrag_8c.html#a2890a953361a1d85a7a3a538809c05df">def_defragFile</a> (unsigned long startCluster)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="defrag_8c.html#ac76c2871c256b4b971510a314f49967f">def_defragTable</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">F32_DirEntry *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="defrag_8c.html#a36b282332b26241fde9848581e96a4b3">entries</a> = NULL</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="defrag_8c.html#a616f9f64a7acc8f4da8f1cb85511e125">cacheCluster1</a> = NULL</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="defrag_8c.html#a39457fda402fba2bac797012fce87e69">cacheCluster2</a> = NULL</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="defrag_8c.html#a4a6da5289fc9ce9e59cc341efd06e540">clusterIndex</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"></div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a4e460b62f6ad1da6647da2f63650cd73"></a><!-- doxytag: member="defrag.c::def_findParent" ref="a4e460b62f6ad1da6647da2f63650cd73" args="(unsigned long cluster)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long def_findParent </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>cluster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function finds parent of cluster from FAT If parameter has value 0, parent is not searched. In the other case whole FAT is being scanned if some cluster links to the cluster given as parameter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cluster</td><td>number of cluster that we need parent of </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of parent cluster of the given cluster or 0 in a case that it is not found or it is root cluster. </dd></dl>

</div>
</div>
<a class="anchor" id="a511415bec7ad1964050f75132234b02b"></a><!-- doxytag: member="defrag.c::def_isStarting" ref="a511415bec7ad1964050f75132234b02b" args="(unsigned long cluster, unsigned long *index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int def_isStarting </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>cluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function determines if a cluster is starting cluster (the aTable is translated) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cluster</td><td>testing cluster </td></tr>
    <tr><td class="paramname">index</td><td>it is output variable that will contain incremented index in aTable, if the cluster was starting. If not, its value will be 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>it returns 1, if cluster is starting or 0 otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a3d279408ee3fb40b39fdb90301698b76"></a><!-- doxytag: member="defrag.c::def_findFirstUsable" ref="a3d279408ee3fb40b39fdb90301698b76" args="(unsigned long beginCluster, unsigned long *outCluster, unsigned long *outValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int def_findFirstUsable </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>beginCluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>outCluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>outValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function find first usable cluster (output is directed into outCluster variable) and its value (the output is directed into outValue). Usable cluster is that can be overwritten (is in the "interval of good clusters") and is not bad. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">beginCluster</td><td>from where we should start to search </td></tr>
    <tr><td class="paramname">outCluster</td><td>output variable - found usable cluster </td></tr>
    <tr><td class="paramname">outValue</td><td>output variable - value of found cluster </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>it returns 1 in case of an error, or 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e92af3739a90669fb870d93b8b97c82"></a><!-- doxytag: member="defrag.c::def_switchClusters" ref="a5e92af3739a90669fb870d93b8b97c82" args="(unsigned long cluster1, unsigned long cluster2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int def_switchClusters </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>cluster1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>cluster2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the most important function - it switches 2 clusters (as in FAT, as in aTable and physically, too). The two clusters are switched in following way:</p>
<ol type="1">
<li>determine if clusters are starting. If yes, update dir entry. In case that one of the clusters is root, then it is necessary to take care of it, i.e. it is necessary to update also bpb (FAT32 can have root cluster anywhere).</li>
<li>update FAT - switch of values in FAT table. If one of or both clusters part of a chain, it is necessary to update its/their parents in FAT - i.e. to switch parent links. In a case that FAT is bad and some cluster links to a free cluster, very serious error will arise that leads to further and worse damage of FAT, because parent will not be found parent (according to next conditions) and there be created cross-reference. Therefore there is possible to use two options:<ol type="a">
<li>assume that FAT is OK and use correct condition for parent searching;</li>
<li>use half (but enough) condition and do not require that clusters should not point to 0.</li>
</ol>
The correct condition for parent searching: If cluster is not starting and its value is not 0, find parent.<br/>
 The half-condition for parent searching: If cluster is not starting, find parent.</li>
</ol>
<p>In my solution I used half-condition only, therefore I had to modify also the function for finding the parent. After these operations, the cluster values are switched in the FAT table - here I have to take care for infinite loop, as it is shown in the following example:</p>
<div class="fragment"><pre class="fragment">      defragmented:  Y -&gt; Y -&gt; Y -&gt; N -&gt; N -&gt; N -&gt; N
      chain       : ...-&gt;213-&gt;214-&gt;2c4-&gt;215-&gt;980-&gt;...
</pre></div><p>And I want to switch 2c4&lt;-&gt;215. Firstly I try normal switch:</p>
<ul>
<li>2c4 is not starting, its parent is 214 (i.e. 214 points at 2c4)</li>
<li>215 is not starting, its parent is 2c4 (i.e. 2c4 points at 215)</li>
</ul>
<p>update of parents:</p>
<ul>
<li>214 will point at 215</li>
<li>2c4 will point at 980</li>
</ul>
<p>and witching FAT values:</p>
<ul>
<li>cluster 2c4 originally pointing at 215 will point at 980 (on value that 215 cluster is pointing at)</li>
<li>cluster 215 originally pointing at 980 will point at 215 (on value that 2c4 cluster is pointing at)</li>
</ul>
<p>After this switch new chain will look like this: </p>
<div class="fragment"><pre class="fragment">       214-&gt;215-&gt;215-&gt;215-&gt;... (circular referrence)
       2c4-&gt;980-&gt;...
</pre></div><p> Therefore I need to perform a precaution. In another case the classic switch will be performed.</p>
<ol type="1">
<li>update values in aTable</li>
<li>last step is switching the data in clusters</li>
</ol>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cluster1</td><td>number of first cluster </td></tr>
    <tr><td class="paramname">cluster2</td><td>number of sectond cluster </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>function returns 0 if there was no error. </dd></dl>

</div>
</div>
<a class="anchor" id="a33103d3c3ed0b1548fc796d18227f6fc"></a><!-- doxytag: member="defrag.c::def_optimizeStartCluster" ref="a33103d3c3ed0b1548fc796d18227f6fc" args="(unsigned long startCluster, unsigned long beginCluster, unsigned long *outputCluster)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int def_optimizeStartCluster </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>startCluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>beginCluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>outputCluster</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function finds a new location (optimal) for starting cluster in case of need. It works by classic algorithm, i.e. it founds closest usable cluster from beginCluster and if it is less than original startCluster, they will switch. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">startCluster</td><td>current starting cluster </td></tr>
    <tr><td class="paramname">beginCluster</td><td>from where we can search for new starting cluster </td></tr>
    <tr><td class="paramname">outputCluster</td><td>output variable - there a new number of starting cluster will be written </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>function returns 0 if there was no error, or 1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a8474fb4182605c5bb62390fd6db533f6"></a><!-- doxytag: member="defrag.c::print_bar" ref="a8474fb4182605c5bb62390fd6db533f6" args="(int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_bar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function draws graphical progress bar from '=' chars. Percentage is computed based on equations: </p>
<div class="fragment"><pre class="fragment">   percent = (number of defragmented cluster) / (number of all used clusters) * 100
   (number of <span class="charliteral">&#39;=&#39;</span>) = size / 100 * percent
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size of the progress bar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2890a953361a1d85a7a3a538809c05df"></a><!-- doxytag: member="defrag.c::def_defragFile" ref="a2890a953361a1d85a7a3a538809c05df" args="(unsigned long startCluster)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long def_defragFile </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>startCluster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function defragments non-starting clusters of file/directory, it works only with a single cluster WARNING! FAT had to be OK, it does not have to contain cross referrences.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">startCluster</td><td>number of starting cluster </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>function returns number of last cluster that was defragmented </dd></dl>

</div>
</div>
<a class="anchor" id="ac76c2871c256b4b971510a314f49967f"></a><!-- doxytag: member="defrag.c::def_defragTable" ref="ac76c2871c256b4b971510a314f49967f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int def_defragTable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function defragments files/directories according to aTable. It allocates memory for clusters cache, then for direntry buffer. Defragmentation runs in a cycle. In that cycle, at first new (optimal) starting cluster is found for actual item in aTable. Then a function for non-starting clusters defragmentation is called. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Function returns 0, if there was no error. </dd></dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a36b282332b26241fde9848581e96a4b3"></a><!-- doxytag: member="defrag.c::entries" ref="a36b282332b26241fde9848581e96a4b3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">F32_DirEntry* <a class="el" href="defrag_8c.html#a36b282332b26241fde9848581e96a4b3">entries</a> = NULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>temporary buffer for directory items (if direntry is updated) </p>

</div>
</div>
<a class="anchor" id="a616f9f64a7acc8f4da8f1cb85511e125"></a><!-- doxytag: member="defrag.c::cacheCluster1" ref="a616f9f64a7acc8f4da8f1cb85511e125" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char* <a class="el" href="defrag_8c.html#a616f9f64a7acc8f4da8f1cb85511e125">cacheCluster1</a> = NULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>1. cache of cluster </p>

</div>
</div>
<a class="anchor" id="a39457fda402fba2bac797012fce87e69"></a><!-- doxytag: member="defrag.c::cacheCluster2" ref="a39457fda402fba2bac797012fce87e69" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char* <a class="el" href="defrag_8c.html#a39457fda402fba2bac797012fce87e69">cacheCluster2</a> = NULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>2. cache of cluster </p>

</div>
</div>
<a class="anchor" id="a4a6da5289fc9ce9e59cc341efd06e540"></a><!-- doxytag: member="defrag.c::clusterIndex" ref="a4a6da5289fc9ce9e59cc341efd06e540" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="defrag_8c.html#a4a6da5289fc9ce9e59cc341efd06e540">clusterIndex</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>index of cluster that is actually defragmenting (it is used for percentage computation) </p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="defrag_8c.html">defrag.c</a>      </li>
      <li class="footer">Generated on Tue Apr 26 2011 11:33:24 for FAT32 Image Defragmenter by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>

</body>
</html>
